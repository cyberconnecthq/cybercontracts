// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity 0.8.14;

import { BeaconProxy } from "openzeppelin-contracts/contracts/proxy/beacon/BeaconProxy.sol";

import { ISubscribeNFT } from "../interfaces/ISubscribeNFT.sol";
import { IEssenceNFT } from "../interfaces/IEssenceNFT.sol";
import { ISubscribeMiddleware } from "../interfaces/ISubscribeMiddleware.sol";
import { IEssenceMiddleware } from "../interfaces/IEssenceMiddleware.sol";

import { DataTypes } from "./DataTypes.sol";
import { Constants } from "./Constants.sol";
import { LibString } from "./LibString.sol";

library Actions {
    // same as IProfielNFTEvents
    event DeploySubscribeNFT(
        uint256 indexed profileId,
        address indexed subscribeNFT
    );

    function subscribe(
        DataTypes.SubscribeData calldata data,
        mapping(uint256 => DataTypes.SubscribeStruct)
            storage _subscribeByProfileId,
        mapping(uint256 => DataTypes.ProfileStruct) storage _profileById
    ) external returns (uint256[] memory result) {
        require(data.profileIds.length > 0, "NO_PROFILE_IDS");
        require(
            data.profileIds.length == data.preDatas.length &&
                data.preDatas.length == data.postDatas.length,
            "LENGTH_MISMATCH"
        );

        result = new uint256[](data.profileIds.length);

        for (uint256 i = 0; i < data.profileIds.length; i++) {
            address subscribeNFT = _subscribeByProfileId[data.profileIds[i]]
                .subscribeNFT;
            address subscribeMw = _subscribeByProfileId[data.profileIds[i]]
                .subscribeMw;
            // lazy deploy subscribe NFT
            if (subscribeNFT == address(0)) {
                subscribeNFT = _deploySubscribeNFT(
                    data.subBeacon,
                    data.profileIds[i],
                    _subscribeByProfileId,
                    _profileById
                );
                emit DeploySubscribeNFT(data.profileIds[i], subscribeNFT);
            }
            if (subscribeMw != address(0)) {
                ISubscribeMiddleware(subscribeMw).preProcess(
                    data.profileIds[i],
                    data.sender,
                    subscribeNFT,
                    data.preDatas[i]
                );
            }
            result[i] = ISubscribeNFT(subscribeNFT).mint(data.sender);
            if (subscribeMw != address(0)) {
                ISubscribeMiddleware(subscribeMw).postProcess(
                    data.profileIds[i],
                    data.sender,
                    subscribeNFT,
                    data.postDatas[i]
                );
            }
        }
    }

    function collect(
        DataTypes.CollectData calldata data,
        mapping(uint256 => mapping(uint256 => DataTypes.EssenceStruct))
            storage _essenceByIdByProfileId
    ) external returns (uint256 tokenId, address deployedEssenceNFT) {
        require(
            bytes(
                _essenceByIdByProfileId[data.profileId][data.essenceId].tokenURI
            ).length != 0,
            "ESSENCE_NOT_REGISTERED"
        );
        address essenceNFT = _essenceByIdByProfileId[data.profileId][
            data.essenceId
        ].essenceNFT;
        address essenceMw = _essenceByIdByProfileId[data.profileId][
            data.essenceId
        ].essenceMw;

        // lazy deploy essence NFT
        if (essenceNFT == address(0)) {
            bytes memory initData = abi.encodeWithSelector(
                IEssenceNFT.initialize.selector,
                data.profileId,
                data.essenceId,
                _essenceByIdByProfileId[data.profileId][data.essenceId].name,
                _essenceByIdByProfileId[data.profileId][data.essenceId].symbol
            );
            essenceNFT = address(
                new BeaconProxy{ salt: bytes32(data.profileId) }(
                    data.essBeacon,
                    initData
                )
            );
            _essenceByIdByProfileId[data.profileId][data.essenceId]
                .essenceNFT = essenceNFT;
            deployedEssenceNFT = essenceNFT;
        }
        // run middleware before collectign essence
        if (essenceMw != address(0)) {
            IEssenceMiddleware(essenceMw).preProcess(
                data.profileId,
                data.essenceId,
                data.collector,
                essenceNFT,
                data.preData
            );
        }
        tokenId = IEssenceNFT(essenceNFT).mint(data.collector);
        if (essenceMw != address(0)) {
            IEssenceMiddleware(essenceMw).postProcess(
                data.profileId,
                data.essenceId,
                data.collector,
                essenceNFT,
                data.postData
            );
        }
    }

    function registerEssence(
        DataTypes.RegisterEssenceData calldata data,
        mapping(uint256 => DataTypes.ProfileStruct) storage _profileById,
        mapping(uint256 => mapping(uint256 => DataTypes.EssenceStruct))
            storage _essenceByIdByProfileId
    ) external returns (uint256, bytes memory) {
        uint256 id = ++_profileById[data.profileId].essenceCount;
        _essenceByIdByProfileId[data.profileId][id].name = data.name;
        _essenceByIdByProfileId[data.profileId][id].symbol = data.symbol;
        _essenceByIdByProfileId[data.profileId][id].tokenURI = data
            .essenceTokenURI;
        bytes memory returnData;
        if (data.essenceMw != address(0)) {
            _essenceByIdByProfileId[data.profileId][id].essenceMw = data
                .essenceMw;
            returnData = IEssenceMiddleware(data.essenceMw).setEssenceMwData(
                data.profileId,
                id,
                data.initData
            );
        }
        return (id, returnData);
    }

    function _deploySubscribeNFT(
        address subBeacon,
        uint256 profileId,
        mapping(uint256 => DataTypes.SubscribeStruct)
            storage _subscribeByProfileId,
        mapping(uint256 => DataTypes.ProfileStruct) storage _profileById
    ) private returns (address) {
        string memory name = string(
            abi.encodePacked(
                _profileById[profileId].handle,
                Constants._SUBSCRIBE_NFT_NAME_SUFFIX
            )
        );
        string memory symbol = string(
            abi.encodePacked(
                LibString.toUpper(_profileById[profileId].handle),
                Constants._SUBSCRIBE_NFT_SYMBOL_SUFFIX
            )
        );
        address subscribeNFT = address(
            new BeaconProxy{ salt: bytes32(profileId) }(
                subBeacon,
                abi.encodeWithSelector(
                    ISubscribeNFT.initialize.selector,
                    profileId,
                    name,
                    symbol
                )
            )
        );

        _subscribeByProfileId[profileId].subscribeNFT = subscribeNFT;
        return subscribeNFT;
    }
}
